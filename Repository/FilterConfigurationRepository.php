<?php

namespace TradusBundle\Repository;

use Doctrine\ORM\EntityRepository;
use Doctrine\ORM\NonUniqueResultException;
use Doctrine\ORM\Query\Expr\Join;
use TradusBundle\Entity\Category;
use TradusBundle\Entity\FilterConfiguration;
use TradusBundle\Entity\FilterConfigurationInterface;
use TradusBundle\Service\Redis\RedisService;

/**
 * FilterConfigurationRepository.
 *
 * This class was generated by the Doctrine ORM. Add your own custom
 * repository methods below.
 */
class FilterConfigurationRepository extends EntityRepository
{
    /**
     * @param array $payload
     * @return bool
     * Note: the payload should be a key value pair, where the key is the ID of the category,
     * and the value is the extra sorts
     */
    public function setCategoryFiltersRedis(array $payload): bool
    {
        $redis = new RedisService(Category::REDIS_NAMESPACE_CATEGORIES_FILTERS);

        if ($redis) {
            return $redis->setByPayload($payload);
        }

        return false;
    }

    /**
     * Getting the filters data from database in order to be saved in Redis.
     * @param int $category
     * @param int $page
     * @return mixed
     * @throws NonUniqueResultException
     */
    public function getCategoryFiltersPayload($category, $search_page = null, $page = FilterConfigurationInterface::PAGE_SEARCH)
    {
        $filters = [];
        $found = false;
        // I've added a try count so i avoid an infinite loop. Better safe than sorry.
        // The maximum tries should be equal with the category depth
        $tries = 0;

        while (! $found && $tries <= FilterConfigurationInterface::CATEGORY_DEPTH) {
            /**
             * @todo Use the translation key instead of the translation text once we have the feature to use this
             * @todo Get filter group once we use this
             */
            $query = $this->createQueryBuilder('f')
                ->select(
                    'DISTINCT f.id',
                    'f.filterType',
                    'f.filterStyle',
                    'f.filterGroup',
                    'f.searchKey',
                    'f.filterOptions',
                    'f.filterExtraOptions',
                    'f.solrKey',
                    'f.showFilter',
                    //'a.translationKey',
                    'a.translationText',
                    'a.attributeType',
                    'a.measureUnit'
                )
                ->leftJoin('TradusBundle:FilterConfigurationCategories', 'fc', Join::WITH, 'fc.filter = f.id')
                ->join('TradusBundle:Attribute', 'a', Join::WITH, 'f.attributeId = a.id')
                ->orderBy('f.filterSort', 'ASC')
                ->andWhere('f.status = :status')
                ->andWhere('f.filterFor = :page')
                ->andWhere('f.deletedAt is null')
                ->setParameter('status', FilterConfigurationInterface::STATUS_ACTIVE)
                ->setParameter('page', $page);

            /* We can add a rule for the search page with no category selected so it will be a default for any page */
            if (! $category) {
                $query
                    ->andWhere('fc.category is null');
            }

            if ($category) {
                $query
                    ->andWhere($query->expr()->orX(
                        $query->expr()->in('fc.category', explode(',', $category)),
                        $query->expr()->isNull('fc.category')
                    ));
            }

            if ($search_page) {
                $show_filter = ($search_page == FilterConfigurationInterface::OFFER_SEARCH ?
                    FilterConfigurationInterface::FILTER_FOR_ALL.','.FilterConfigurationInterface::FILTER_FOR_OFFER_SEARCH :
                    ($search_page == FilterConfigurationInterface::DETAILED_SEARCH ?
                     FilterConfigurationInterface::FILTER_FOR_ALL.','.FilterConfigurationInterface::FILTER_FOR_DETAILED_SEARCH
                      : ''));
                $query
                    ->andWhere('f.showFilter IN (:showFilter)')
                    ->setParameter('showFilter', explode(',', $show_filter));
            }

            $filters = $query->getQuery()->getResult();

            /**
             * If we don't find a filter for this category we search a filter for a parent category.
             * @var CategoryRepository
             */
            $categoryRepository = $this->getEntityManager()->getRepository('TradusBundle:Category');
            $category = $categoryRepository->getParentCategory($category);
            $tries++;
            if ($filters) {
                $found = true;
            }
        }

        /**
         * I will expect that at this point we have filters for every page so i don't check if it exists
         * If we get at this point with empty filters we might have a problem
         * We need to also add the attribute options and return as an array.
         * @var AttributeOptionRepository
         */
        $optionsRepository = $this->getEntityManager()->getRepository('TradusBundle:AttributeOption');
        foreach ($filters as &$filter) {

            /**
             * For the checkbox filter we return a list of all attribute options.
             * @var FilterConfiguration
             */
            $optionBoxes = [
                FilterConfigurationInterface::FILTER_TYPE_CHECKBOX,
                FilterConfigurationInterface::FILTER_TYPE_RADIO,
                FilterConfigurationInterface::FILTER_TYPE_SELECT,

            ];

            if ($filter['filterOptions'] && in_array($filter['filterType'], $optionBoxes)) {
                $ids = explode(',', $filter['filterOptions']);
                $options = $optionsRepository->getOptionsByIds($ids);
                $filter['filterOptions'] = $options;
            }

            if (isset($filter['measureUnit'])) {
                $filter['measureUnit'] = ! empty($filter['measureUnit']) ? $filter['measureUnit'] : null;
            }

            /*
             * For the range text filter we return some defaults values/keys for from and to
             */
            if ($filter['filterType'] == FilterConfigurationInterface::FILTER_TYPE_RANGE) {
                $values = [];
                if ($filter['filterStyle'] == 'dropdown') {
                    $values = unserialize($filter['filterExtraOptions']);
                    unset($filter['filterExtraOptions']);
                }
                $filter['filterOptions'] = [
                    'from' => [
                        'name' => $filter['searchKey'].'_from',
                        'label' => 'From',
                        'values' => isset($values['from']) ? $values['from'] : [],
                    ],
                    'to' => [
                        'name' => $filter['searchKey'].'_to',
                        'label' => 'To',
                        'values' => isset($values['to']) ? $values['to'] : [],
                    ],
                ];
            }
        }

        return $filters;
    }
}
